---
layout: post
title: 关于循环不变式
categories:
- 算法与基础
tags:
- 循环不变式
- 面试题
- Go语言
---

最早接触循环不变式是在[『编程珠玑』][1]这本书上，其中有一章节提到了快速排序算法，然后以很清晰的思路将这个经典算法讲解得十分通透，以至于过了三四年我还记忆犹新。

循环不变式类似于数学归纳法，都是需要问题从初始状态到最后状态（数学归纳法实际上不存在终止状态）的这整个过程都保持正确性。在程序验证中，循环不变式扮演着一个重要的角色，尤其是那些边界条件很容易让人混淆的情况下。本文以算法面试中碰到的一些问题为例，说明循环不变式是如何清晰地表述整个算法，并保证程序的正确性，事实上循环不变式在[之前的一篇文章][2]中也提到过。

首先，是一个很简单的算法题：

> 将一个整数数组中的数重新排列，使得所有的偶数都在奇数之前

这个问题实际上很简单，其变形也很多，如快速排序中的一个重要步骤划分数组就是与这个问题类似，只不过条件由奇偶判断变成了与枢纽轴比较。下面是Go语言的一个实现：

    func PartitionEvenOdd(arr []int) int {
        isEven := func (val int) bool {
            return ((val & 1) == 0)
        }

        boundary := 0
        for i := range(arr) {
            if isEven(arr[i]) {
                arr[boundary], arr[i] = arr[i], arr[boundary]
                boundary++
            }
        }
        return boundary
    }

其循环不变式可以描述为：数组中`[0, boundary)`这个子数组的元素始终为偶数。而要验证循环不变式的正确性，我们需要验证三个部分：

1. 初始情况下，循环不变式是正确的
    * 由于`boundary`初始情况下为0，所以`[0, boundary)`为空集（注意左闭右开区间），显然是正确的
2. 循环过程中，表达式仍然维持其正确性
    * 在循环过程中，由于不变式中右边是开区间，所以`arr[boundary]`的奇偶性是可以不确定的，如果当前元素为偶数，那么我们可以将该元素与`arr[boundary]`交换，同时`boundary++`以保证集合中元素全为偶数。
3. 当循环终止时，循环不变式依然正确
    * 显然如此，循环终止情况下，数组中所有元素都得到处理，这时所有的偶数都能被放到`[0, boundary)`上，所以数组就被划分为奇偶两个部分了。

从上面这个例子，就可以看到，循环不变式就是要保证程序在整个循环过程中都维持表达式的正确性，并通过验证三个部分来保证此条件。

这个时候再回头实现快速排序就会很简单了，毕竟快速排序最困难的地方就是在数组的划分上。

看完本文后，可以再看一下之前的[那篇文章][2]，对比循环不变式的验证过程，以了解循环不变式是如何被应用到实际的场景中。

[1]: http://book.douban.com/subject/3234692/
[2]: /2013/09/binary-search-and-variants/

