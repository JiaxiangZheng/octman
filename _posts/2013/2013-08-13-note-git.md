---
layout: post
title: GIT学习
categories:
- Tools
tags:
- git
- tools
- programming
---

Git是一个高质量的版本控制工具，这几天花了些时间学习几个比较常用的Git命令，这里记
录一下，供自己日后回顾使用。因为目前还没有用到类似于搭建服务器或者多人合作建立
Git，分布式Git等高级的功能，所以这些都没有涉及，但对于单机的版本控制，下面的
这些内容是够用的，而且这篇记录也会随着我后来的不断学习而添加新的内容。

学习Git，最有用的工具莫过于`git help [cmd]`了，查看某个命令的帮助后，后台自动会
打开对应命令的完整文档网页，唯一的缺点就是例子不够丰富，这个时候可以求助*Google*
或者自己在机器上多实验几次。

### `git add`  

`git add`用于将文件添加到缓存索引中，如果这个文件之前没有被添加到跟踪列表，那么
这个文件将被添加到跟踪列表并被缓存索引，等待被提交（`commit` ）。一般情况下可以
用`git status`来查看当前被跟踪索引的情况。显然，一个文件一个文件地添加是很麻烦的
，所以 git允许我们用`git add prefix*`或`git add folder/*`来使用星号表达式支持多
文件添加。显然，像编译过程中会产生很多中间文件，如果用上面的这种星号表达式，显然
会把这些中间文件添加到跟踪列表，所以需要用一个名为`.gitignore` 的文件把所有不想
被Git跟踪的文件或文件夹或类似的星号表达式以行为间距加入到 `.gitignore`文件。

### `git rm`

另外，如果我们不小心添加了一个我们不想跟踪或添加到缓存中的的文件，有什么办法可以
把这个文件从列表中删除呢？`git rm`可以为我们提供这样的功能，其中如果用`git rm
file`，不仅仅会把文件从跟踪列表或缓存列表中移除，同时还会把物理文件也给删除掉，
而`git rm --cached file` 则只执行前半部分的操作，而不会把真实的文件给删除，这通
常对于我们来说是更有用的。

### `git status`  

这个命令是用来显示当前的Git状态的。它会告诉我们有哪些文件还没有被添加到跟踪列表
（`untracked files`），有哪些被跟踪但被更新导致没有添加到缓存中的（`changes not
staged for commit`），有哪些被跟踪而且已经添加到缓存中等待提交（`changes to be
committed`）。下面这张图可以很清晰地说明上面的三种情况，而它提示的几个命令对于我
们来说也是比较有帮助的。如`git reset HEAD (file)... to unstage`。

![](http://octman.com/images/2013/git-status.jpg)

### `git commit`  

用于提交之前添加到缓存中的文件，一旦执行这个命令，Git历史中就会包含一次提交记录
。一般都是在`git add`之后，等待所有当前任务完成后再提交的。有时候，我们修复了一
个bug后，就可以执行这个命令将最新的修改提交掉了；但是如果我们不小心漏了一个文件
没有被添加到缓存从而导致该文件的修改没有添加到提交记录中，那我们需要怎样才能把这
个文件添加到提交记录呢？重新建立一个新的提交显然是可行的，不过由于这个文件与修复
bug是一起的，所以希望还是把这个文件提交到刚刚的提交记录中，这个时候可以用`git
commit --amend`，它不会重新建立一个提交，而是将这个提交包含到之前的那个提交记录
中，这样，提交次数就没有发生变化了，而这次的提交SHA还是原来的那个。

### `git log`

当我们提交了很多次记录后，怎么查看这些记录呢？`git log`提供了这个功能，一般情况
下它会包含一个SHA，提交人以及对这次提交的描述等，这会导致每个记录信息比较繁杂，
一些扩展选项可以让我们以简短的形式查看提交记录。比如，我就会经常使用`git log
--pretty=oneline`这个选项来查看记录，当然，`git log`包含的选项是非常丰富的，它甚
至允许我们指定显示最近一周内的提交记录，以我们指定的格式显示结果，只显示某位提交
者所提交的记录等等。

### `git diff`

用于比较差异的一个工具。可以用来比较两次提交中某个文件的差异，也可以比较当前修改
的文件与最近一次提交的仓库中对应的文件差异，还可以比较两次提交内容全部的差异。所
以，这是一个非常有用的工具。

当修改了一部分代码以后，我们想了解某个文件与提交的文件差异，可以使用`git diff
file`；如果想比较现在所有修改了的文件与提交文件的差异，直接用`git diff`就可以了
。如果要比较以前某两次提交记录的差异，使用`git diff SHA-1 [file-1] SHA-2
[file-2]`就可以了，其中如果`[]`中的内容省略的话，比较的就是整体的差异，即每个文
件的差异都会被显示出来。

前面说了那么多怎么提交，那么如果我今天提交了很多次记录，但我想回到今天提交的第一
次记录所在的那个状态，要怎么解决呢？那就需要好好看看`git revert`和`git reset`这
两个命令了。

### `git revert`

`git revert`表示撤销某次操作，此次撤销操作之前的提交全都会保留起来，而这次撤销操
作将会单独地当作一个新的提交操作记录在操作列表里。如果想要指定某个文件恢复到某个
状态，那么用`git checkout commit file`来完成，注意，这个操作完成后，恢复的文件将
会被加入到缓存等待提交，如果不想它加入到缓存，可以用`git reset HEAD`把缓存重新清
除到最初状态，这个时候文件就是`changed but not staged`而等待添加了。

### `git reset`

不同于`git revert`，这个命令主要用来将当前的代码库重新设定为某次提交所在的状态。
而这个提交之后的所有提交记录都会丢失。这个命令的好处就在于如果有一个错误的提交是
无效的，我们可以用`git reset HEAD^`回到之前一个提交状态；如果有好几个提交都错了
，那么就直接重置到这几个提交操作之前。

注意，这里有个选项`--soft|mixed|hard`，其中`soft`表示只将提交记录表重置为目标提
交状态，而真实的物理文件不作修改，即保持为未被跟踪或更新未被加入缓存，这样我们就
可以查看当前文件与我们回到的提交状态时文件有哪些差异了。而如果选项为`hard`，则物
理文件也全部进行了修改为缓存中所在的状态了。有时候，这个操作会比较危险，因为它无
法回到后面的提交状态。

### `git branch`

Git与其它版本控制工具最大的差异（或者说相对于其它的工具最大的优点）就是其对分支
的优异支持。分支是什么？当多人合作或多个模块同时进行开发的时候，我们不希望它们之
间相互干扰。可以分别从主分支（master）中衍生出多个从分支，然后各分支（假设分别为
A，B）由于是不同的模块，因此可以独立进行开发，当某个从分支A的模块完成后，可以将
该A分支与主分支（master）合并。而其它的模块继续开发，等到完成后再与主分支合并。
另外，如果B分支想要把A已经完成的功能添加进来，只需要将master分支与B合并，这样B
分支就包含了它自身修改的那部分内容，也包含了A已经完成的部分了。另外，如果B修改了
A所涉及的那部分内容而引起合并冲突，这需要我们手动地去把这些冲突给解决掉（在逻辑
上，这是非常合理的，如果A删除了某个文件中的某一行，而B添加了那一行，那到底谁对谁
错呢，计算机当然无法判断，就得交给人来做这件事情了）。所以说，分支对于版本控制工
具来说，是一个极其重要的功能。

下面列举的是常用的一些关于分支的命令，注意，这里没有涉及到关于远程分支的概念，也
就没有所谓的`rebased`和`pull`等命令了。

    git checkout -b branch-name   // 新建一个包含与当前分支内容相同的分支并切换到新建分支
    git branch -v                 // 显示所有分支及其最后一次提交信息的一个列表
    git checkout branch-name      // 切换到一个分支
    git branch branch-name        // 新建一个包含与当前分支内容相同的分支，命令1等价于命令3加4
    git branch -d branch-name     // 删除分支，如果这个分支还有没有提交的修改内容，将会提示删除失败。
    git merge branch-name         // 合并某一分支到当前分支

一旦我们处于某一分支下，我们就可以对这个分支里的内容进行修改了，而且这些修改对其
它的分支是不影响的。

所以，一般情况下，可以维护一个`develop`分支，日常的开发可以在这个分支中进行，而
`master`主分支中用来维护稳定的代码。一旦`develop`中某个模块已经稳定，可以将它合
并到`master`分支中等待发布。
