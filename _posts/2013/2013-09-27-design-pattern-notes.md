---
layout: post
title: 设计模式初探
categories:
- 程序设计
tags:
- programming
- software
---

经典设计模式包含23种，在平常的程序设计中经常会有意无意地使用到其中几种，因此很有必要系统地进行学习；此外，设计模式可以简化代码的整体框架和结构，使用设计模式指导而写出来的代码可以很容易进行扩展。正如C++的模板编程一样，使用设计模式可以使不同的模块相互正交，从而组合扩展生成无穷的结果。下面是自己对其中常用的几种模式的一点笔记。

### 23种设计模式汇总

REMARK：下面是23种设计模式汇总，在我们的日常使用过程中，其实无需太关注或套用具体的某一种模式，能解决问题的方法都是好方法。

1.	抽象工厂
2.	适配器
3.	桥接模式
4.	Builder
5.	职责链
6.	命令模式
7.	组合模式
8.	装饰模式
9.	外观模式
10.	工厂方法
11.	享元模式
12.	解释器
13.	迭代器
14.	Mediator
15.	备忘录
16.	观察者模式
17.	原型模式
18.	代理模式
19.	单例
20.	状态模式
21.	策略模式
22.	模板方法
23.	访问者方法

### 迭代器模式

用于顺序地访问一个容器中每一个元素，而无需了解容器内部是如何构造的，也不用管它里面的元素是什么。这样，客户端与容器的数据结构本身可以相互独立。

以STL为例，`vector`和`list`以及`map`都提供了`begin()`这类返回迭代器的函数，我们在遍历这些容器的时候，只需要调用`auto it = container.begin(); it != container.end(); ++it`这样的代码，具有很强的通用性，完全无需关注内部是线性连续存储还是非线性存储结构。如果这样还不够让我们惊叹的话，考虑使用Go实现一个接口，然后对于具体的每一个类实现这个接口以后，我们就可以在一个包含所有实现接口的对象集合中进行访问，而无需关心该对象实际到底是什么了。

注意，这个时候，容器是需要返回迭代器的接口的，在C++这样支持泛型编程的语言中，当然可以直接用模板实现，在Go语言中，一般是使用`interface`来实现抽象迭代器的，而具体的容器则需要实现出定义的接口。具体的迭代器本身和具体容器本身是相互了解的，这需要由容器实现者提供。

### 组合模式

继续前面的迭代器模式，这里可以考虑另一种情况，如果元素是一种树状组织的结构（*不同于二叉树这样的树状结构，而是说其类型本身是一个树状的结构，具体可以看下面的例子*），而且元素本身又是一个树状结构或表状结构，这时用迭代器去遍历就显得无能为力了。（别忘了，即使是非线性的结构，如`map`，迭代器模式只能线性地访问其中的每一个元素）。使用组合模式，我们可以弱化这个整体与局部概念，使得**整体和部分可以被一致对待**[^1]。

**举个例子**，一个公司有各种部门，但是它可能还有诸多其它的分公司，而且小地方的分公司与总公司的各个部门是同一层次，小地方分公司又包含了各种部门，这种显然就是一个树状的结构。

可以定义一个抽象的组合类，它包含一个抽象类指针的列表，每一个指针可以指向具体的元素（树中叶子结点），或者一个组合的表结构（非叶结点）。事实上，组合模式中还可以利用迭代器模式，见下面的例子。

在Go中又可以把基类定义成接口。

下面是C++代码实例：

    class AbstractComponent {
    protected:
        std::list<AbstractComponent*> pChilds_;
    public:
        void add(AbstractComponent*);    // useless in LeafComponent
        void remove(AbstractComponent*);    // useless in LeafComponent
        virtual void print() = 0;
    };
    class LeafComponent {
    public:
        void print();   // print the concrete item value
    };
    class NonLeafComponent {
    public:
        void print() {
            for (auto it = pChilds_.begin(); it != pChilds_.end(); ++it) {
                (*it)->print();     // note that the *it can still be NonLeafComponent
            }
        }
    };

不过有一个不好的地方就是抽象的类需要把叶子类与非叶子类的通用功能都声明一遍，然后各子类实现自己需要的功能，就像例子中的`add()`和`remove()`。在《Effective C++》中，它认为错误最好在编译期就体现出来，这里对于叶子类来说，`add`等函数实际上是运行期体现其错误的。当然，也可以将add和remove这类非叶结点才有的功能只放在非叶结点中实现，这样叶子类就不必实现这些没有意义的接口了，不过这样叶子与非叶子类不再具有统一的接口，需要客户端进行相应判断，不再透明。

### 模板方法

模板方法是一个非常重要的模式，它可以在不改变整个算法框架的情况下对每一个小步骤的实现进行重写。以点云ICP配准方法为例，基本的步骤包括：

* 两片点云中对应点对的选择 
* 噪声点对过滤 
* 刚体变换估计
* 迭代再重新计算刚体变换。

而每个小步骤中都是可以有多种实现的方案的，如刚体变换的估计可以用线性最小二乘逼近，也可以用LM非线性能量最小化，还可以用点到平面的法向一致性估计等。因此，可以定义一个模板方法把这些待实现的抽象接口按算法流程进行调用，同时对外公开该模板接口。而具体每个实现的细节可以继承对应的抽象接口。考虑实现`ICP`类作为抽象类，对外它公开`registration`接口，它包含这些流程组合出来的结果，以用于配准；而对子类则开放一系列的虚函数接口，即实现的细节。对于子类来说，它们只需要实现对应的虚函数接口即可。

在C++中，模板方法一般声明为`public non virtual`函数，而抽象接口则声明为`private`或`protect virtual`函数。

在这里记住Hollywood准则，即*“Don't call us, we will call you”*。

### 单例模式

单例模式也是一个非常重要并经常被使用的模式，设想有一个日志模块，所有的日志都需要由一个对象来记录，因此，将日志类实现成单例模式是显然的。另外，平时也在不知不觉中用过这个模式。有一个类`GlutViewer`用于显示窗口，表示成一个基类，包装了基本的注册函数和基本的显示过程和Arcball，但一个程序中只希望有一个窗口，所以可以将它设计成单例，后面继承出来的也是一个单例，只需要将显示的内容相关的函数进行改写就可以了，而外界调用其实不需要对这个继承类了解过多。

具体实现起来，可以将类的构造函数（包括赋值和等号重载）私有化，然后对外接口为`getInstance()`返回出该类对象的指针，实际上指针指的对象则要么是一个静态的元素，要么就在堆上只分配一次。在堆上分配的方法可能会造成线程的不安全，最好还是用静态元素。

**注**：C语言的单例用全局变量定义，这无法在本质上避免只生成一个对象。

### 状态模式

又称为**State Pattern**，它将状态集合中每一个状态表示成具体的状态类，真正的状态转移则由Context决定。而客户端完全不需要知道具体的状态是如何改变，以及有多少状态。如果是比较复杂的框架结果，使用状态模式当然达到了解耦目的，但注意防止滥用。

### 策略模式

与状态模式抽象类的状态不同，策略模式把类的行为本身抽象成一个接口，继承该抽象接口，然后运用组合方法（钟爱组合而非继承），包含接口，而具体用哪一个实现出来的接口则可以依实际而定，从而达到解耦的目的。

可以配合模板方法使用，它对应于模板方法中某一个步骤中各种不同的实现细节。

**与状态模式的区别**：策略模式将能够完成相同工作的不同算法抽象成了不同的类，继承自一个基类，这样客户端调用的时候可以非常方便地做更改而不用关心具体的实现细节；对于状态模式来说，则是每个状态被抽象成了一个子类，每个状态类本身负责自身的状态转化，对于客户端而言，它只需要知道抽象类即可。这两种模式都可以用[工厂方法]创建子对象。

### 观察者模式

用于处理和维护对象间的一致性。又称发布订阅模式。关键对象是目标和观察者。观察者模式用于一对多的关系模式。目标的状态一旦发生改变，它就得通知所有它的观察者去改变对应的行为。如在一个用户界面工具下，后台数据看作是一个目标，不同的表格或图来表示这些数据的变化可以看作是它的订阅者，这样可以根据这些表格来订制对应的观察者，一旦数据发生改变，观察者就会去改变这些表格或图的行为。

注意，由于都是抽象层相互通信，而具体的细节在继承类里实现，这样就把耦合程度降到了最低。另一方面，由于观察者之间互相是不知道的，而且也不知道目标的状态改变会引起的代价，因此这可能会是一个问题。

不仅仅是一个目标多个观察者，同时这个模式可以应用到多目标情况，这时需要扩展update
接口以告诉观察者是哪一个目标的状态发生了变化。

一个对象状态发生改变，与它相关联的所有依赖体都需要被通知并更新状态。

换一个思路，如果是使用泛型的方法，是不是可以考虑将Subject写成一个抽象的模板类，具体的Observer以模板参数的形式表现，这样以后就不需要再考虑继承的一个体系，只需要对外能够实现Subject中调用的那些接口即可。而对于Observer，实际上它不需要与Subject有相关性，只需要实现出更改自身及被Subject调用的接口。

### 适配器模式

用于使用库时将其接口转化为用户所需接口。现实生活中这样的例子也不少，比如电源插头，在内地的三孔插座电器拿到香港可能就无法插入到电源插头中了，这个时候可以用一个第三方的适配器，使得内地的电器在香港的电源插头中也可以使用，而这个时候适配器扮演的就是一个粘合剂的作用，将两个本来接口不对头的东西适配到了一起。以STL为例，stack和queue就是两个adaptor的例子，分别装deque的接口重新包装，使得分别支持栈和队列的操作，而优先队列则是对vector进行的包装。

### 装饰模式

**仍需仔细想想**

装饰模式无须破坏原有对象的结构和封装，却可以为该对象额外增加职责行为。装饰类具有与原对象相同的接口，因此它也是继承自与原对象相同的基类，只不过在修饰类与基类之间有一层抽象修饰类作为过渡。

注意，这里并非强调继承，装饰类与对象之间的交互实际上是通过组合而来的，继承主要是为了保持接口的一致性和抽象性，使得外界可以不用关心具体是一个原始的对象还是一个被包装后的对象。

### 工厂方法

与new生产一个具体的对象不同，工厂类可以根据实际的需要生产出不同的对象，它生产出的对象都是继承自某一基类的组件。

### 抽象工厂

与[工厂方法]不同，它相当于工厂方法的一个集合，对于每一个具体的类，都需要相应地增加其工厂类，即工厂类与具体类是一一对应的。而抽象工厂则最好实例为一个单例。

一个具体的例子如下：如窗口系统界面库，一般不同的操作系统下其图标按钮，窗口等各组件风格应该都不相同的，因此可以将不同OS平台下这一系列的组件之间独立开，然后实现一个抽象类作为基类，即工厂基类，具体的操作系统实现出工厂子类，等到调用时，只需要对工厂类调用即可。如果是一个或两个组件，使用抽象工厂会比较啰嗦，但一旦组件数量非常多，则使用抽象工厂将是一个非常明智的选择。

    class IconBase; class WinIcon; class LinuxIcon;
    class FacotryBase {
    public:
        virtual IconBase* createIcon() = 0;
    };
    class WinFactory : public FacotryBase {
    public:
        WinIcon* createIcon() {
            return new WinIcon;
        }
    };
    class LinuxFactory : public FacotryBase {
    public:
        LinuxIcon* createIcon() {
            return new LinuxIcon;
        }
    };
    int main() {
        pFactory = new WinIcon; // if the system is win system
        IconBase* pIcon = pFactory->createIcon();
        // ...
    }

### 工厂与抽象工厂的区别

抽象工厂与工厂方法都可以将具体的实现解耦开来，但它们之间还是有很大的区别。虽然二者都是生产对象，但工厂方法是通过继承，而抽象工厂则是通过组合。

工厂方法通过继承生产对象表现在所生产的组件全是兄弟类，即它们之间继承自同一个基类。对于客户端，它只需要了解基类，然后传入不同的参数给工厂对象，就可以生产出不同的对象产品。具体如何选择则由工厂方法来实现。

抽象工厂通过组合生产对象表现在它生产出来的是一系列的相关产品，不像工厂方法生产出来的都是单个的组件，抽象工厂生产的是一类组件。因此，如果需要增加每一类组件，那么需要做出比较大的修改，而且不同类需要实现出对应的工厂类。事实上，对每一类，可以用工厂方法实现出其包含的所有组件。即在这个意义上，抽象工厂可以看作工厂方法的集合。

### 桥接模式

抽象类与抽象类交互，实际的行为由派生类负责。大大地解耦了类结构之间的关系。可以应对多维度的变化，只需要修改具体的子类，而不同类之间则继续由抽象类打交道。注意到，实际上可以重构为桥接模式就说明两个不同类是垂直正交的，或者说采用“正交策略”将一个类拆分出相互正交的两个类，然后组合在一起工作。实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少其耦合。

**个人觉得这是一个非常有用的模式**

### 命令模式

将请求封装成一个个的对象，从而可以用不同的请求对客户进行参数化，对请求排除或记录请求日志，以及支持可撤销的操作。

[^1]: 《大话设计模式》第19章。
