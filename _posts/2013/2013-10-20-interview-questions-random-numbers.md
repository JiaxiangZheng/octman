---
layout: post
title: 随机数相关的面试题
categories:
- 算法与基础
tags:
- 面试题
- 算法
- 随机数
---

考虑以下几个问题：

1. 随机打乱一个数组
2. 从一个包含n个元素的数组中随机地选择m个元素，并使得输出的元素是有序的
3. 蓄水池抽样问题
4. 完美洗牌问题（实际上不算是随机数相关的问题）
5. 如何测试随机程序是足够随机的，即如何验证问题1答案的正确性

rand\_shuffle和蓄水池抽样问题的相通之处。shuffle还有一些相应的扩展问题，与随机数
相关的算法，比如给定可以产生1\~5的随机数生成器，如何使之随机地产生1\~7。下面分别
就这些问题进行相应的讨论。

### 随机洗牌问题

首先是随机洗牌问题，它等价于随机打乱一个数组，使得重新排列后的结果是完全随机的。
一般而言，采用如下算法：

    for i:=1 to n do swap(a[i], a[random(i,n)]);

选择第一个元素的概率为$\frac{1}{n}$，这样就应该把这个元素固定下来到第一个位置，
然后第二个元素被选择的概率为$\frac{n-1}{n}\cdot{}\frac{1}{n-1}$，以此类推，每个
元素概率都是相等的。

    func RandShuffle(data []int) {
        Len := len(data)
        for i:=Len-1; i>=0; i-- {
            j := rand.Int() % (i + 1)
            if j != i {
                data[i], data[j] = data[j], data[i]
            }
        }
        return
    }

### 随机抽样

与下一个蓄水池问题不一样，随机抽样问题假设元素的总量是已知的。我们可以如何进行选
择呢？一种方式是每次从数组中随机地选择一个元素，并放到一个集合`set`中，这样就可
以保证是随机地选择了。但是这样的话，判断元素在集合中是否重复可能会耗费比较大时间
。如果采用哈希表，时间上可以降低，但空间复杂度就很高了。另一方面，与上一个问题联
系起来，如果我们先将数组随机地打乱然后再取前m个元素呢？这也是一种可行的方案。但
它会改变数组本身，有时候是不可行的。

考虑这样一个方法：因为是要求每个元素被选概率都是$\frac{m}{n}$，那么对于第一个元
素，以$\frac{m}{n}$的概率选择它（这可以通过生成1-n之间的一个随机数，如果随机数大
于m则不选，否则选择它），如果不选它，则对于下一个元素以$\frac{m}{n-1}$，否则就以
$\frac{m-1}{n-1}$概率选择。于是，利用一个临时变量记录当前已经选择元素的个数$T=0$
，则对第$i$个元素以$\frac{m-T}{n-i}$概率选择。

    func RandSelect(n, m int) []int {
        out := make([]int)
        for i:=0; i<n; i++ {
            j := rand.Int() % (n-i)
            if j < m {
                out = append(out, i)
                m--
            }
        }
        return out
    }

### 蓄水池抽样问题

问题描述：

>  给定一个数组，有可能数组大小太大，以致于内存无法装下，我们只能渐进式地将它加载到
>  内存中，假设数组大小为N，那么如何才能足够随机地从中选择m个元素？如果要求按有序输
>  出，又该如何处理？

首先，什么叫足够随机地从N个数组中选择m个元素呢？即每个元素被选中的概率都是$\frac{m}{N}$。显然，由于数组大小未知，我们只能在遍历每个元素的过程中就得把它确定下来选与不选，一旦不会被选中，则它当然不会存在于最终结果中；如果它被选中，则它还有可能会被后续的元素给替换掉，从而综合两种情况使得元素最终被抽中的概率为$\frac{m}{N}$。这需要怎样的选择策略呢？

可以采取如下策略：首先对于数组中前$m$个元素，将它放入备选的结果中，当处理第$m$个元素之后的每个元素时，首先以$\frac{m}{i}$的概率选择该元素，然后如果没有选中，则继续处理下一个元素，否则从结果中随机地选择一个元素，将第$i$个元素替换掉结果中选择的元素。很简单的一个策略，但确定是能够保证到每个元素被抽中概率的。见下面结果的证明。

**证明**：  
下面简要地描述一下其中的数学证明，可以跳过，不影响阅读。注意，我们需要证明的是：每一个最终选中的元素都是以$\frac{m}{N}$的概率被抽中的。记$x_i$为第$i$个元素，$S_i$为处理到第$i$个元素后所抽取的结果。

如果$m=N$，那就意味着数组中所有元素都被选中，显然满足条件，下面考虑m小于N且i大于
m的情况。对于$x_i$，它出现在$S_i$的概率为$\frac{m}{i}$。而对于任意元素$x_j$（j小
于i），它出现在$S_i$当且仅当它出现在$S_{i-1}$且没有被$x_i$替换掉。通过归纳法，我
们假定了$x_j$出现在$S_{i-1}$的概率为$\frac{m}{i-1}$，则$x_j$出现在$S_{i-1}$的概
率为$$P\{x_j\in{}S_i\}=\frac{m}{i-1}\cdot{}\frac{i-1}{i}=\frac{m}{i}$$。证毕。

**补充**：  
突然想到其实可以不用数学归纳法的，我们可以求每个元素最终被选中的概率，如下：

1. 当 $i>m$ 时， $x_i\in{}S_N$ 当且仅当处理到第 $i$个元素时，它会被选中与前面的进行替换，而且在处理后面的元素时，不会将该元素给替换掉。为表示方便，记处理后面的元素$x_j$，则它包含$x_j$不被选中，概率为$\frac{j-m}{j}$和$x_j$被选中但不会替换$x_i$，概率为$\frac{m}{j}\cdot{}\frac{m-1}{m}$，于是$P\{x_j不会替换x_i\}=\frac{j-1}{j}$。，即$$P\{x_i\in{}S_N\} =\frac{m}{i}\cdot{}\frac{i}{i+1}\cdots{}\frac{N-1}{N}=\frac{m}{N}$$
2. 当 $i<=m$ 时，很容易看到当处理到第m个元素之后的每个元素，只要它们没有替换掉$x_i$，那么就可以满足要求，相当于上式中$i=m$的情况。显然也是$\frac{m}{N}$。

代码可以写成如下：

    func ReservoirSampling(n, m int) []int {
        out := make([]int, m)
        for i:=0; i<n; i++ {
            if i<m {
                out[i] = i
            } else {
                j := rand.Int() % i
                if j < m {
                    out[j] = i
                }
            }
        }
        return out
    }


### 随机数生成

最后，再来一道开胃题，给定随机数生成函数`rand1_5`，它可以等概率地生成1\~5中的每
一个整数，如何利用这个函数等概率地生成1到7呢？

**答案**：注意到我们平时生成1\~N的随机数采用的一般是`rand() % N + 1`这种方法，如
果我们可以随机地等概率生成一组序列始得$N>7$，那么也可以采用类似的方法。可以考虑
利用`rand1_5`生成两个数，将这两个数作变换使结果分别取到1\~25，这时就可以选择前面1到21，然后对7取模了。

    func randGen1To5() int {
        return (rand.Int() % 5) + 1
    }

    func randGen() int {
        res := 25
        f := func(n int) int {
                return rand.Int() % n + 1
            }
        for {
            if res <= 21 { break }
            res = 5*(f(5) - 1) + f(5)
        }
        return (res-1) % 7 + 1
    }

### 随机程序的正确性

我们应该如何验证呢？有两个方式，一个是数学上的严格证明，另一个是利用蒙特卡罗方法
，即让计算机大量地重复一个实验，并计算出对应数据的频率，如果它的频率与估计的概率
接近程度与数据量成任意的正比，那么就是足够随机的了。

举个例子，为了验证一个随机数产生器\[0-5\]的正确性，可以分配一个计数器数组，重新
产生大量的随机数，并将产生的随机数对应的计数器自增，最后统计每个计数器中的结果是
否基本一致。一般而言，实验重复的越多，那么就越接近。另外，[这篇博文][1]也深入地探讨了相关的问题。

[1]: http://coolshell.cn/articles/8593.html

### 参考文献：
1. [计算机程序设计艺术]第3.4.2节
2. [编程珠玑]第12章


[计算机程序设计艺术]: http://book.douban.com/subject/1231891/
[编程珠玑]: http://book.douban.com/subject/3234692/




